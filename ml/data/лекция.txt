 так всем доброго дня мы сегодня с вами продолжаем наш курс и наша цель на сегодня закончить рассмотрение большой темы посвященные конечным автоматом а и перед началом нашего занятия пока мы тут настраивали я выписал некоторые факты которые нам сегодня потребуется доказать давайте вспомним что у нас было в предыдущей серии ничего не было да да мы рассмотрели с вами с теоретической точки зрения как устроена минимизация и мы с вами поняли что минимальный pdk существует единственная источница до изоморфизма единственный вопрос который у нас остался как этот автомат строить точнее алгоритм по которым мы можем строить минимальный автомат а и для этого мы ввели несколько определений сейчас я их повторю на доске точнее на презентации мы с вами доказали существование снасть автомата и вот наша цель сегодня будет вот такая то есть это во первых построить алгоритм нахождения минимального пдк дальше ввести понятие новые новые понятия в нашем курсе который будет называться порождающей грамматики дальше выстроить иерархию порождающих по грамматик и понять какой класс грамматик будет эквалентен такому понятию как автоматы это наш план на сегодня и давайте закроем наш технический долг по сравнению с предыдущим занятием давайте напомню что у нас была эквалентность двух состояний выпады к по словам длины не больше чем n на слайде после главы длины не больше чем к на презентации мы понимаем что это множество от это отношение является отношениями эквалентности и класса эквалентности мы можем обозначать как фактор множества q по отношению тильде с количеством букв n и дальше как лемма которые мы с вами будем доказывать ее можно формулировать по-разному можно сказать что если два состояния эквивалентны, то они q-2 эквивалентны, либо сказать следующее, что если у нас в какой-то момент времени классы эквивалентности совпадают, количество классов эквивалентности совпадает, то и у нас происходит насыщение нашего графика. Давайте я еще раз черчу график, который мы построили с вами с прошлого раза. Мы сказали, что мощность q дельта k у нас q дельта 0, кто помню чему равняется сколько у нас классов и квалитности по словам для минимум больше чем 0 2 это завершающие не завершающие состояние дальше у нас строится график и в какой-то момент времени мы с вами должны выйти на насыщение потому что классную квалитности у нас сверху ограниченное количество состояния в автомате и наша цель как раз понять что как только у нас в нашем графике найдется такой момент времени к штрих что класса эквивалентности совпадают дата и дальше класса эквивалентности будут совпадать тем самым мы можем по факту предъявить критерии останова для нашего алгоритма и так давайте тогда докажем этот факт значит как он будет доказываться во Во-первых, мы можем сказать всегда, что классы эквивалентности, которые у нас есть, не больше, чем следующие классы эквивалентности. То есть у нас количество классов эквивалентности может только совпадать. Теперь, как доказать, что если у нас с вами классы эквивалентности совпали, то и следующий класс эквивалентности тоже будет совпадать? Смотрите, что мы можем сделать. Если у нас... Давайте я нарисую картинку. Представьте себе, что у нас есть класс. Зачастую класс у нас будет распадаться. То есть у нас есть один класс по и плюс один эквалентности. И как он может распасться? Он может распасться по какой-то букве. То есть у нас получаются наши слова разбиваются на два отдельных класса. Значит, когда у нас классы будут совпадать? нас классы будут совпадать в том случае если мы возьмем два состояния из разных классов по соотношению эквивалентности и плюс 2 и покажем что эти слова были не эквивалентны в предыдущем состоянии то есть у нас такой картинки быть не может что у нас были два состояния и плюс 2 не эквивалентны но и плюс 1 эквивалентная то есть нам нужно пока что наши классы не разбиваются дальнейшем вот поэтому давайте мы рассмотрим два слова которые не не и плюс 2 эквивалентным наша цель будет доказать что эти слова не и плюс 1 эквивалентный тогда мы докажем наш факт поехали значит а тогда что мы можем с вами сказать мы можем с вами сказать что без ограничения общности существует некоторое слово w и сигма со звездой такое что дельта q1 в принадлежит множеству завершающих состояний дельта q2 в не принадлежит множеству завершающих состояний да конечно вот но тогда что мы можем сделать с этим словом но на самом деле из этого слова мы можем выбрать слово первую букву этого слова пусть а это будет 0 буквы этого слова тогда что у нас получается тогда у нас будет существовать слова в равное такое что дельта причем смотрите длина у нас сверху будет ограниченный и плюс 1 и тогда у нас получается что дельта q1 а принадлежит и здесь у нас получается дельта q2 а у не принадлежит f ну кажется логично а теперь смотрите что у нас получается у нас получается что вот эта вещь это по свойству ассоциативности у нас q1 а а вот эта штука это дельта дельта q2 а у смотрите что у нас выходит у нас выходит что существует слово у длины не превосходящие и плюс 1 такие что состояние если мы стартуем на состоянии дельта q1 а и дельта q2 а то у нас слова различаются из этого мы можем сделать вывод следующий что у нас дельта один а не эквивалентен по и плюс один со словом дельта q2 так это понятно но мы знаем что класса эквивалентности по и такие же как классы эквивалентности по словам длины и плюс 1 а это значит что в данный момент наши слова не разбились следовательно мы можем сказать что дельта один а будут не не эквивалентным и по словам длины и мы используем сужение нашего слова то есть мы взяли и сузили наш наше ограничение на то что существует слова не длины не больше чем и плюс 1 а существует слова длины не больше чем и вот это самый важный переход тогда у нас смотрите существует у штрих такое что у штрих длины не больше чем и такое что дельта давайте я тут уже сокращу а штрих опять же тут можно сказать без ограничения общности потому что ну какой-то из случаев у нас будет выполняться не обязательно что именно здесь принадлежит вот этот состояние будет лежать может завершать состоянии а здесь у нас получается в дельта q2 а у штрих будет не лежать f но из этого как раз будет следовать что у нас с вами что получается q1 не будет эквивалентен q2 по словам длины не превосходящим чем и плюс 1 все доказали наш факт опять же тут неважно где у нас будет работать принадлежность непринадлежность это особо роли не играет доказать что будет ровно одним и тем же понятно что если мы хотим допустим использовать отрицание этого всего факта то нам нужно будет переходить в сделать весь вывод в противоположную сторону так хорошо понятен ли это факт как он доказывается взяли два состояния эквивалентно сократили длину слова по которому проверяем эквивалентность и дальше уже мы пляшем тем что у нас состояние эквивалент так окей давайте дальше значит тогда у нас еще раз воспроизведение картинки у нас есть два состояния два класса эквивалентности и в какой-то момент времени класса у нас не бывают и стабилизируется в итоге мы доходим с вами до финального варианта вот и более того мы знаем за какое количество шагов мы найдем эти классы эквивалентности а это нам позволяет оценить асимптотику нашего алгоритма асимптотика алгоритма нахождения минимального автомата кто может сказать какая она будет у нас если у нас есть смотрите pdk и нам нужно построить мпдк да не больше чем q квадрат смотрите почему потому что на каждый шаг мы тратим модуль q на модуль сигма состояний а потому что нам нужно перебрать переходы по автоматам по каждому алфавиту а и того получается мы получаем оценку сверху на модуль сик хорошо с этим мы с вами разобрались вот дальше тут есть на слайде примеры вот который позволяет это рассмотреть но суть в чем суть нашего алгоритма будет стоять следующем что мы должны будем взять и ходить брать произвольную букву и смотреть по этой букве разбиваются у нас класс или не разбивается. Если разбивается, мы выделяем классы эквивалентности, если не разбивается, то мы оставляем это все в одном и том же классе. Алгоритм у нас оканчивается тогда, когда мы за один шаг алгоритма, перебрав те буквы, которые у нас имеются, мы не обновили классы. Почему это работает собственно это мы ровно сейчас и доказали вот это вот так вот работает алгоритм вот тут есть пример собственно я сейчас тут оставлю его для тех кто смотрит лекции на ю тубе собственно здесь нужно взять классы эквивалентности 0 1 2 и посмотреть в какие классы они переходят то есть у нас вершина 0 1 2 исток изначально у нас 0 это завершающий один не завершающий дальше мы смотрим в какие классы мы с вами переходим то есть обозначаем на пересечении строки из топ-2 какой класса колец мы попадаем в итоге один класс эквивалентности у нас будет таким а дальше повторяя этот шаг собственно из 0 по а мы по вам попадать во второй класс потому что из 0 по а мы идем в qs а qs 2 класс повторяя эти действия мы получаем следующую вещь что у нас два класса эквивалентности совпали а это значит что вершину 0 и 2 мы можем смерть жить вот на самом деле они образуют один класс эквивалентности. И в итоге у нас получается с вами вот они разделение классов. И в итоге наш MPDK получается таким образом. Теперь смотрите важное замечание как читать презентации. На самом деле этот пример тянется с самой первой презентации. То есть мы там строили регулярные выражения, по регулярному выражению мы строили автомат, потом его делали полным, минимизировали вот получили вот такое чудо-юдо вот то есть мы давайте еще раз повторим алгоритм который вам кстати не на контрольной придется выполнять мы с вами строим н к с однобуквенными переходами дальше мы убираем эпсилон переходы есть сначала мы строим in case не более чем однобуквенными переходами потом мы убираем на всем переходы после этого строим декабрит томпсона строим пдк и минимизируем этот автомат и потом его можно подавать как вход определенного алексера вот потому что количество стоянием автомате нам тоже будет важно так хорошо теперь давайте двинемся следующая задача мы с вами тут говорили очень много про количество классов и эквивалентности что она у нас конечно теперь давайте подумаем и зададим себе вопрос что то мы можем сказать про то, что если у нас есть какой-то алфавит, мы с вами на самом деле понимаем, что если у нас L это автоматный, то сигма со звездой у этому класса будет конечна. Почему? да мы можем построить канонический mpdk м0 ну и получается что в нем количество классов эквивалентности равно количеству классов по языку да хорошо теперь давайте подумаем что будет в обратную сторону если у нас у нас количество классов и калитности конечно то как построил как доказать что язык является автоматным да то здесь у нас возникает естественная конструкция. Давайте напишу KMPDK. То есть здесь мы пользуемся, что язык автоматный, значит по нему можно построить NK, после него мы строим канонические MPDK, получаем количество классов и эквивалентности. Ну или даже какое-нибудь ограничение сверху пишем. вот и тогда смотрите мы если у нас вот эта штука конечно мы строим канонический мпдк и дальше нам нужно будет доказать что завершающее состояние распознают наши слова напоминаю в каноническом мпдк у нас множество состояний f это на самом деле следующее это множество классов у такие что классы эквивалентности U такие, что U принадлежит нашему языку L. То есть, когда мы с вами будем доходить до завершающего состояния, мы на самом деле будем получать классы эквивалентности нашего языка, которые лежат... точнее мы будем получать классы эквивалентности слов, которые лежат в нашем языке. А это значит, что это те слова, которые у нас лежат в языке. То есть у нас получается естественная конструкция как этот факт формулируется значит сразу скажу запоминайте фамилию имя потому что это теорема достаточно важная хотел от сейчас она у нас получилось следствие всех тех фактов которые есть по факту доказательства этой теоремы заключается в том что мы предъявляем алгоритм построения канонического мпдк 4m называется теоремы махиллани роуда и формулируется она следующим образом что май это критерий автоматный тогда я только тогда когда количество классов и квалитности по языку будет конечно то есть если лима разрастание у нас не является критерием то теорема махиллани роуда у нас является критерием собственно как теперь доказать что любой язык у нас является не автоматом давайте рассмотрим пример язык а венты в венты почему этот язык не автоматный значит нам нужно на самом деле предъявить бесконечное количество классов эквалентности ну давайте рассмотрим слова укаты это обкат и когда на нашу цель будет доказать что укаты не эквалентно никакому уельскому давайте попробуем предъявить слова которая нам нужно дописать к обкаты чтобы у нас слова лежал в языке а другое слово не лежало в языке нам нужно приписать слова справа ну да на самом деле можно по моему я услышал ответ можно использовать слова в катай то есть мы делаем приписку к нашему слову к нашему у к тому и уэльтому и тогда это слово лежит в языке от слова не лежит в языке все у нас получилось счетное подмножество нашего множество сигма со звездой в котором у нас любые два слова попарно не эквивалентны а это значит что количество классика колец и бесконечно значит наш язык не автоматный вот вот так вот это все доказывается это кайсом воспроизвели а вот он пример тоже здесь есть хорошо значит давайте я спрошу остались ли вопросы по теме автоматы ну что мы закончили вот как раз достаточно большой блок посвященный автоматным языкам окей по этой теме вы пишете первый контроль через неделю давайте теперь попробуем перейти к следующему классу и чем этот класс будет навеян если класс автоматных языков у нас навеян лексическим разбором то есть нам допустим нужно определить какой части речи находится принадлежит слова ну или какие-то выделить там части речи и части нашего слова там предлог окончания то здесь мы переходим на более высокий уровень мы переходим с вами на язык слов значит и здесь мы уже встречаемся с таким понятием как предложение предложение у нас зачастую из чего состоят из слов да и нам нужно посмотреть допустим определить наше предложение является простым или сложным да как это я щас запутал конечно давно ирут простым или составным а вот и дальше нам нужно выделить допустим подлежащие сказуемое обстоятельства дополнения там и любые другие синтаксические конструкции вот и здесь нам нужно будет посмотреть как раз он моргнул не справляется и здесь нам нужно уже вести более мощную абстракцию которая поможет нам прыгнуть с уровня автоматных языков потому что вот такие конструкции как слова вида а в нтб в нт здесь уже не распознается а как бы мы любой язык программирования которые мы с вами напишем мы можем написать ним произвольное количество фигурных скобочек открытых и произвольное количество закрытых скобочкой к минимум нам скобочный баланс хотелось бы проверять и поэтому нам нужно будет ввести новое определение определение будет следующим и вводим такое понятие как грамматика собственно понятие порождающей грамматики вел на омхомский в конце 50-х годов и собственно вся вот эта культура которая есть она пошла именно от него поэтому давайте мы введем определение давайте вообще сделаем новую тему порождающей грамматики и введем определение. Значит, мы будем называть грамматику g порождающей. Вот такой объект, это порождающая грамматика. Значит, из чего она будет состоять? Значит, n это у нас будут не терминалы не терминальные символы я их буду называть не терминала они называются еще вспомогательными мощность этого множества будет меньше чем бесконечность дальше второе сигма это алфавит или терминальные символы алфавит у нас будет конечный и важное свойство у нас множество терминальных и не терминальных силов не должны пересекаться между собой третье правило это с давайте с видео принадлежащий n это стартовый не терминал и 4 этапе значит это интересное подносят это множество выводящих правил значит как мы его обозначим его обычно обозначает вот таким вот интересным свойством что значит у нас должен быть как минимум один не терминал. Что у нас получается? Плюс без сигма со звездой. То есть у нас есть хотя бы один не терминал, из которого мы будем что-то порождать. И выводить мы будем слова вида n объединить сигма со звездой. Правила будут записываться таким образом. Допустим, альфа выводит бета то есть наша цель будет следующая взять собственно в нашей строке где-то найти каким-то образом написанный символ альфа и попытаться его заменить на символ бета раскрыть правил пример чтобы вы сразу понимали а да действительно иначе фигня согласен давайте я не помню если этот пример в презентация но он такой полезный значит Давайте я напишу пример грамматики из реальной жизни. Пример. s у нас выводит noun group, verb group. Это, если что, два нетерминальных символа. Дальше noun group это у нас, допустим, subject и adjective. verb group это у нас что это такое у нас давайте предположим verb под verb и subject это у нас noun adjective я не знаю как прилагательный как будет этот давайте в маленьким буквами пишу вверх это был допустим у нас вверх вверх и от вверх я забыл как а простоятельство в общем давайте буду маленьким буквам обозначать теперь смотрите пример конь пример которые подходят окей сложно у меня а например значит слова кошка египетская могла скакать высоко вот предложение значит из каких частей речи он состоит это предложение состоит это на он это у нас adjective могла это у нас вверх это вверх это у нас отверг вот эти слова это у нас символ алфавита вот это важно а дальше мы их объединяем в правило значит это у нас сабжект это у нас получается adjective это у нас два правила получается это у нас вверх это у нас отверг значит здесь у нас получается вверх групп вот это у нас получается на он групп и вот это у у нас предложение у нас получается наше слово лежит языке задаваемой этой грамматикой понятно что это конкретный пример но в целом вот у нас грамматика у нас есть здесь объекты вида n это все что с большой буквы я напишу символов алфавит это то что у нас с маленькой буквы у правила написаны вот так хорошо давайте спрошу понять ли этот пример так хорошо давайте разбираться значит смотрите если мы в предыдущих примерах которые предыдущих примерах которые у нас были что мы с вами делали у нас было какое-то конкретное физическое слово имя это физическое слово разбирали по буквам здесь мы поднимаемся в с практической точки зрения на более высокий пример что мы разобрали наши слова по бокам а теперь нам надо предложение научиться разбираться по словам то есть мы поднимаемся чуть чуть на более высокий уровень, мы будем опять же все формализовать вот такие же степени, просто теперь в нашем случае символы алфавита это будут наши слова, которые мы хотим распознать или какие-то токены, там допустим открывающие скобки, закрывающие скобки, квадратные скобки открываются, квадратные скобки закрываются, там ключевые переменные тоже могут быть, а дальше мы будем строить правила, по которым мы раскрываем, пытаемся распознать нашу программу то есть наша цель допустим определить нашей программе если синтаксические ошибки в этой программе для этого у нас есть про грамматика и есть правила которые задаются этой грамматикой что образно говоря с и каждой открывающей скобкой у нас должна идти какая-то закрывающая скобка в нашем правиле вот поэтому этот эта концепция достаточно практичная которая есть вот то есть мы пытаемся с вами как раз это сделать давайте чуть более простой пример пример вот такой у нас будет не терминала а б а б то есть это уже такой математический пример а не давайте подумаем над следующим фактом как понять какое слово выводится в грамматике что мы делали с вами с автоматами когда мы пытались определить какое слово вводится какое слово не выводятся что мы с вами водили мы кажется выводили понятие штопор отношении выводимости было такое ну и здесь там нам тоже будет вывести это отношение что мы говорим мы говорим в том топор это наименьшее рефлексивное транзитивное отношение рефлексивное но я отношения над n объединить сигма со звездой такое что смотрите на любых и все из сигма со звездой альфа тарелочка бета принадлежащим правилам нашей грамматики мы можем сделать следующий вывод и Фи альфа Пси выводится за один шаг, опять же, мы можем сказать в нашей грамматике G, символ добавить, Фи бета Пси. То есть по факту получается, что мы можем взять в этой строке левую часть правила заменить на правую часть правила. То есть как распознается слово? Мы можем сказать, что sentence мы заменяем на noun group, group дальше на он группу заменяем на саджик тифа джеки в первую группу заменяем на вверх подверг сам сам джеки фан заменяем на на ум аджиктив заменяем на и джек тиф вверх заменяем на композицию двух вербов отверг заменяем на отверг вот и цель наша будет следующая мы будем говорить что язык задаваемой грамматикой грамматика же это будет следующий объект это множество всех слов которые откуда выводятся из с то есть наша цель стартовать и стартового не терминала извините за эту автологию, и раскрыть наше слово w целиком. Вот, то есть это наша цель. Значит, тут дальше идет пример. Так, давайте я оставлю его как раз в качестве примера висеть. Вот, допустим, в этой грамматики слово a, a, b выводится вот таким образом. Он пока будет висеть во время перерыва можно на него позалипать и позадавать вопрос все значит перерыв делаем до 1307 так давайте продолжим мы с вами продолжаем наш блог понятно ли что в этом примере происходит давайте поясню значит смотрите с мы раскрываем на а.б. раз потом мы берем вот эту букву а заменяем на а б б вот у нас все в данном случае из нашего контекста будет равна и б дальше мы можем б б видите мы можем в принципе заменять произвольное количество терминалов вот это средняя б б у нас заменяется они правая б б заменяется на б большой бы маленькая дальше бы большое бы маленькая заменяется у нас получается господи я запутался а вот вот эти две больших б заменяется на бы большой бы маленькая а дальше бы большой бы маленькой заменяется на а вот получаем слово вопрос такое хочу задать вас не снимать не смутило что я два раза запутался ну так вот это означает что во первых в грамматике неплохо было бы зафиксировать порядок разбора это раз а во-вторых возможно что у нас одно слово может распознаваться несколькими способами это будет называться неоднозначной грамматика но сегодня про это мы не будем говорить давайте мы введем вообще какие виды грамматику нас существуют это важно значит первое грамматики это порождающей грамматики они могут использовать любые правила которые у нас есть вторые грамматики называется контекстно зависимыми а у них правила будут иметь такой вид что у нас с вами символы которые есть они будут вот таким образом так значит у нас получать давайте я буду сразу табличку клепать правило и 3 столбец оставлю еще значит порождающие грамматики это у нас правило альфа стрелочка бета их обозначим дальше контекстно-зависимой грамматики и альфа там все господи и а си будет выводить фи альфа psy при этом альфа не пустое множество ведь видите чтобы вывести правило нам нужно чтобы мы выводили его из не терминала при этом то что остается слева и справа у нас фиксируется да то есть вот как раз зависимость от контекста тут левая и правая часть называется контекст вот и здесь она сохраняется при выводе правил да обязательно не терминал да кстати перерыве мне подошли и сказали важное свойство что забыл сказать что все не терминалы будут обозначаться большими буквами и терминалы будут обозначаться маленькими буквами а все греческие буквы это последствия терминалов и терминалов дальше контекста свободной грамматики это грамматики которая имеет вид а стрелочка альфа и есть четвертый класс грамматик они называются либо право линии нами либо лево линейными в зависимости от того какой вам способ написания по душе праволинейные да конечно же объясню почему во втором правиле пустые не пустые я конечно это доказывать не буду ну бы льв б вот у нас правило будет иметь вот такой вид теперь краткое пояснение почему альфа не пустое потому что если внезапно здесь окажется альфа пустым то можно показать что класс контекста зависимый грамматик будет точно таким же как класс порождающих грамматик это сложный факт мы его доказывать не будем вот поэтому здесь очень важно что альфа не пустое так теперь смотрите зачем мы это все нарисовали нам нужно с вами понять где в данном месте находятся автомата где в этой иерархии для этого у нас будут правый столбец который мы назовем машины как вы думаете где в данной иерархии будут находиться автоматы на правление грамматика Потому что... Давайте покажем почему. Для этого рассмотрим пример следующего вида. Да-да-да-да, я забыл написать. Я хотел это написать. w и сигма со звездой, а получается a и b это символы, а не терминалы. И все будут n объединить с сигмой со звездой. Так, значит, пример. Наше любимое слово avenne-bevenne. На самом деле, грамматика для него достаточно простая. Из s мы вводим asb, Или из S выводится пустое слово. Все. Собственно, на семинарах должны будут показать, как это доказывается. Ну, вкратце делается следующее, что если нам нужно доказать, что эта грамматика задается этим словом, то нам нужно сделать вывод. Что у нас получается? а венты минус 1, а венты б венты. Дальше мы говорим следующее. В обратную сторону мы можем сделать индукцию по длине вывода. вывода. Значит, база. У нас s за один шаг выводит слово w, следственно слово это пустое, это раз. А второе, что у нас есть, переход. У нас из S получается выводится за один шаг ASB, а по предположению индукции у нас выводится слово A, Aventa, Bventa, A. Ой, B. Ну а это есть слово вида а венты б венты вот то есть это краткий переход там будут идеи разные на семинарах рассматриваться в общей за скобочным баланс так то есть смотрите то есть мы с вами показали по крайней мере что автоматы это точно не контекст свободные языки к те свободные языки у нас шире и теперь на тут сайте будет еще пример к коза грамматики можно будет посмотреть вот и теперь будем соответствие делать между видами грамматика my и машинами так сейчас нам надо будет вспомнить курс математической логики какие абстракции пожалуйста коллеги спамы и помогите коллегам другим какие абстракции вы проходили на курсе математической логики машины тюринга как вы думаете где они находятся здесь нет нет я на это порождающей грамматики то есть в принципе мы можем эмулировать любую вычислимую функцию то есть проверять результаты бывающему функции значит теперь давайте дальше следующий класс это контекстозависимой грамматики это так называемая linear bounded машины тьюринга то есть машины тюринга у которых ограничено количество используемой памяти вне его контекста я не помню как я их там назвал в презентации они в обратную сторону идут у меня хорошо на чё-то как свободные грамматики у нас эквивалентны автоматом с магазины памяти магазины памяти значит что скрывается за термином магазинная память затеряно магазинная память скрывается стек просто это у нас будет автомат которому сбоку стек приделали вот и мы будем платить некоторую сумму со стека для того чтобы пройти по какому-то переходу и дальше мы будем класть некоторое количество элементов на стек но вот как раз про автомат с магазинной памяти мы будем с вами говорить чуть позже пока нас это не будет интересовать значит в контексте свободных контекст зависимых у нас ограничены будут не давайте напишу английская linear bounded не до термин и stick машин тюринга вот это просто неудачный перевод на русский потому что на русском этого термина по факту нет вот и любые правила грамматики задают нам автомат с машинами тюринга значит давайте подумаем собственно что мы сегодня с вами успеем доказать мы сегодня на самом деле с вами успеем доказать что класс праволинейной грамматики и плак класс автоматных языков это на самом деле одни и те же класса то есть наша цель будет построить по любой праволинейной грамматики автомат и по любому автомата построить праволинейную грамматику и это доказать linear bounded недетерминистик машины Тьюринга. Это на английском языке, а на русском это ограниченные недетерминированные машины Тьюринга. Так, то есть мы сейчас с вами будем доказывать следующую теорему, что множество автоматных языков равно множеству языков, задаваемых праволинейными грамматиками. теорема множество классов ох и мы эквивалентно классу, точнее класс автоматных языков, эквивалентно классу управления грамматикой. Давайте докажем этот факт. Значит, доказательства. первое что мы с вами построим это попробуем доказать что по автомат сейчас давайте подумаю ну это основная идея что на самом деле состояние в автомате это будет некоторые не терминал в грамматике исток поэтому мы будем с вами сначала построим по грамматике автомат и так значит пусть у нас была грамматика же эта грамматика n sigma ps и мы с вами будем строить следующий автомат он будет выглядеть следующим образом кстати тут бага презентация я поправил автомат будет выглядеть следующим образом в качестве состояния у нас будет n объединить со множеством завершающих состояний дальше у нас сигма дельта определим сейчас у 0 а у нас будет стартовое состояние ой стартовый не терминал и множеством завершающих состояний у нас будет qf теперь перехода это важный момент мы будем говорить следующее что если у нас есть правило а выводит bv то мы будем делать следующее мы из а по слову дубль в будем выводить слово б если у нас из а в есть переход по букве b а я не то написал если у нас из а идет переход по слову дубль в.б. и объединяем это все с переходами следующего вида что из а дубль в мы можем дойти до состояния qf в случае если у нас есть правило в грамматике а вот w то есть по факту мы просто выкидываем букву которая у нас есть справа в наших правилах мы вводили а wb это мы перекладываем в картинку такую что у нас есть состояние а и по слову по слову дубль вы мы переходим состоянии б так теперь нам нужно будет доказывать что или тем равняется или g в данном случае так конструкция понятно просто и по факту мы будем с вами накапливать цепочку которая у нас имеется так значит это у нас правило грамматики теперь нам нужно будет доказывать два утверждения давайте еще всех обсуждают первое что если у нас из а вводится дубль в б эпсилон то у нас вводится грамматика и второе утверждение что если у нас выводится второе утверждение то и слова обводится слова дубль в итак дать их запишу первое утверждение что из а выводится в грамматике и псу он тогда и только тогда когда у нас и сам выводится дубль в б и второе у нас будет выводиться qf и все он да и только тогда когда а у нас выводят дубль в вот на самом деле здесь можно сделать хитрее я тут подумал завести просто в грамматики новое состояние которое у нас будет выводить терминал но давайте попробуем вывести это так значит из этого будет следовать доказательства значит первое давайте докажем все эти факты одновременно первый шаг это индукция по не вывода в автомате м это у нас длина вывода в автомате пусть так будет обозначаться а значит база начнем первый шаг значит выводим из за ноль шагов Значит что у нас получается? Смотрите, у нас получается, что давайте писать из a w выводит b epsilon за 0 шагов, соответственно у нас получается a равняется b, дубль выравняется и тогда наша цель будет доказать что из а выводится эпсилона ну а из а выводится а а это эпсилона значит дальше второй переход давайте проверим работает он значит а из w выводится qf эпсилон мы не можем эту штуку вывести за ноль шагов потому что qf это не объект наших правил грамматики поэтому этом случае мы с вами не разбираем переход давайте рассмотрим первый переход который у нас есть нашем автомате да да они давать после рассматривать последний переход с этим будет удобнее значит что мы говорим здесь переход будет аналогичный значит мы говорим что из а дубль в за какое-то число шагов мы вводим слова c и потом за один шаг мы вводим слова b и все так ну давайте думать что у нас тогда получается когда у нас дубль в это некоторое слово иксу из этого будет следовать что из а x у нас выводится слова с эпсилон то есть право контекст мы с вами можем убрать значит и второй шаг который у нас есть это из c выводится b и ps он за один шаг из этой штуки у нас получается что из c мы можем вывести убэ а из вот этой штуки по предположению индукции мы можем вывести следующий что из а у нас водится xc все ну и тогда смотрите что у нас в итоге выходит данном факте из этого у нас выходит следующую что из а у нас выводится xc и здесь вывод из c мы раскрываем у b получаем x у b а x у b это у нас что такое а это как раз у нас дубль в.б. теперь то же самое мы повторяем с переходом в пустое слово значит из а до бульбе мы выводим c у выводим за один шаг в пепси но опять же мы говорим что в дубль выравняется иксу аналогично мы получаем с вами а выводят у нас слова xc вот а из вот этой штуки у нас будет следовать следующие что c выводит у вот по правилам по переходам автомате который у нас имеется типа если у нас есть такое правило она порождается вот таким переходом так ну и что у нас получается тогда здесь получает за один шаг мы раскрываем с вами иксу вот который является словом w это переход в одну сторону так хорошо теперь переход в обратную сторону переход в обратную сторону индукция по количеству выводов правила грамматики по длине выводов грамматики же а база чем у нас база получается за сколько шагов ну можно за ноль шагов тогда у нас получается а выводит дубль в б за ноль шагов следовательно у нас получается а равно b дубль в равно пустому слову ну и тогда получается у нас смотрите что из а по пустому слову да действительно мы выводим а пустое слово при этом а у нас равняется b так переход не говорю здесь просто писанины будет вот просто такая знаете как это муторная писанина переход мы говорим следующим что из а рассмотрим последний переход которая у нас есть тесно мы понимаем что а вот некоторые слова дубль в.б. значит существует такое c что а вводят xc а это будет x у б а вот это у нас слово дубль в ну дать теперь обратно собирать что у нас получается у нас получается что дать сразу цепочку писать что и состояние а по слову x у мы по предположении индукции можем съесть слово x на и получить у нас получается что а мы грамматику не построили у нас есть грамматика и мы по ней построили автомат на потом еще вторая часть будет доказательства где мы по автомату будем грамматику строить и здесь у нас по правилам грамматики получается что у нас есть собственный переход из c по у ой на по у и мы приходим слова бы вот если у нас ты за вывод дубль в б значит существует такое c что из а вот x а дальше в эти x за один шаг посмотрим последнее раскрытие нашего не терминала а тогда что у нас получается c за один шаг в эту след на есть у нас правило нашей грамматики следует но у нас есть переход в нашей грамматики в нашем автомате получаем вывод в qf и все это не стрелочка это у нас вот ну а дальше мы говорим следующее что тогда у нас а x по предположению индукция будет выводить состояние x и y и все итоге получается что из а и x у мы выводим сначала c и u а потом выводим курим склепа и все мы доказали этот факт теперь смотрите что мы должны сделать теперь мы должны доказать что язык задаваем и грамматика язык задаваем автоматом это один и тот же собственно где мы это с вами будем делать давайте мы с вами как раз сотрем индукцию и оставим это здесь что у нас выходит в итоге и того у нас слово которая лежит в языке задаваемым автоматом находится тогда и только тогда когда существует q из f которая в нашем случае это qf что из q0 w мы получаем с вами q и псилон то есть у нас получается, что это эквивалент тому, что у нас есть переход из q0 по w в qf ипсион. Что такое q0 у нас? С. Счеркиваем, ставим S. А тогда полемия это эквивалентно тому, что что что мы доказываем? Так, мы доказываем а получается как раз подстав подстановка вместо а с место qf qf значит у нас получается из с выводит слово дубль в а это эквивалент потому что слово дубль вы лишит физике задаваем наши грамматики я понимаю что доказательство произошло за 4 минуты это просто цепочка выкладок ну как просто цепочка выкладок так давайте вопросы по этой части так у кого есть мысли как по этому как его так мы по грамматике построили автомат как по автомату грамматику построить сложно на самом деле также можно вы по факту что нам нужно сделать нам нужно взять наше состояние и на перри переходы перегнать обратным способом останется только понять что мы делаем завершающими состояниями ну а по завершающим состоянием мы можем сказать что у нас будет просто правило что с завершающим состоянием выводить пустое слово давайте как раз это мы напишем с вами так выводим из автомата грамматику так пусть у нас м это у нас ку стигма дельта ку 0f когда мы построим грамматику же следующего следующего толка значит у нас правило не терминал у нас будут ровно такими же как множество состояний стигма это алфавит да кстати тогда смотрите очень важный момент который по факту у нас может быть кто его заметит я сейчас буду писать пока правила перехода а вы мне скажите пожалуйста правило у нас будут иметь следующий вид значит мы будем говорить с вами что у нас получается правило будут такие q1 будет у нас иметь слова в q2 если у нас q1 в у 2 лежит дельта не объединить с тем что у нас к 1 будет выводить дабы льв ой один будет выводить опцион если q1 лежит множество завершающих состояниях то кто нашел подвох здесь есть подвох до штуку и сима не пересекаются нет называли как это фиксирую как это править но в целом да можно сказать что давайте продублируем все состояния которые у нас есть буковки с и копируем у нас же по факту алфавит это конечное множество поэтому это можем сделать так теперь смотрите что нам нужно будет с вами в этом в этом месте показывать нам нужно будет показать следующее что собственно q1 выводит дубль в q2 тогда я только тогда когда иску 1 дубль в у нас выводится q2 и псу а здесь у нас получается q1 выводится слово дубль в тогда я только тогда когда у нас получается искать существует завершающее состояние такое что иску 1 в выводится q и псу вот значит так избавиться от знака существования на самом деле сказать что у нас ровно одно завершающее состояние в нашем автомате такое мы делать умеем так ну чё давайте тогда показывать это все дело опять же 2 индукция я предлагаю доказать индукцию слева направо потому что она чуть чуть сложнее вот индукцию справа налево оставить качестве упражнения так поехали значит индукция справа на ли слева направо значит по числу шагов по длине выводов нашей грамматики база базансер так база у нас и будет состоять из какого количества шагов мы видим из нуля шагов мы получаем с вами что q1 за ноль шагов выводят дубль в q2 лет на дубль вы равняется эпсилон q1 равняется q2 вот и тогда мы получаем следующее что из у 1 эпсилон да действительно мы за ноль шагов даже получаем q2 эпсилон чего честно а теперь переход которая мы с вами строим давайте рассмотрим наверное последний переход который у нас есть есть у нас существует q такое что из q1 до такой переход у нас получается сейчас мы закончим значит существует опять разбей на какие-то слова xv так что у нас исходим получается x выводится q какое-то у и дальше за один шаг мы выводим с вами q2 и псион так что это у нас получается тогда давайте прикидывать значит тогда у нас получается q1 x выводят получается q и все он да а это по предположению индукции у нас получается что ох ё-моё я я да я курился бамбука правильно я что-то в обратную сторону начал доказывать час секунду а значит что это у нас отлично в один вывод какой в 1 q1 выводит в q2 значит существует некоторая q что иску 1 у нас выводятся xq а дальше у нас выводится что x q2 за один шаг но тогда из этого будет следовать что у нас во первых низку за один шаг выводится у q2 а здесь у нас получается иску один у нас выводится за какое-то количество шагов x x q логично так и из этого значит по предположению индукции будет следовать что иску 1x у нас выводится qy а здесь у нас получается по определению нашего автомата где она у нас там было получается у нас есть вывод иску 1 выкупается он мой просто в кой так не просто иску в q2 и все все и тогда получается следующее что у нас с вами идет вывод из q1 господи x да все вывод идет в q и дальше вывод идет в q2 и псу вот то есть мы получили наш вывод значит теперь про второй пункт про второй пункт на самом деле там тоже самое только надо добавить везде квантов существование на завершающее состояние состояния.
