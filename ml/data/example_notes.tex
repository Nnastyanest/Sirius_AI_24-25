\documentclass{article}
\usepackage[english, russian]{babel}
\begin{document}
\section{Конспект лекции: Конечные автоматы и порождающие грамматики}

\subsection{Минимизация конечных автоматов}
\begin{itemize}
    \item Существование единственного минимального \textbf{ПДКА} (с точностью до изоморфизма).
\end{itemize}

\subsection{Алгоритм минимизации}
\begin{itemize}
    \item Введение понятий \textbf{экзистенциальных} и \textbf{однозначных} состояний.
    \item \textbf{Лемма эквивалентности}: два состояния эквивалентны по словам длины $n$, если они эквивалентны по словам длины $n-1$.
\end{itemize}

\subsection{Порождающие грамматики}
\begin{itemize}
    \item Введение понятия \textbf{порождающей грамматики}.
    \item Иерархия порождающих грамматик (\textbf{Тип-0}, \textbf{Тип-1}, \textbf{Тип-2}, \textbf{Тип-3}).
    \item Эквивалентность между классами грамматик \textbf{Тип-3} и \textbf{ПДКА}.
\end{itemize}
\section{Критерии Останова Алгоритма}

\subsection{Теорема}
Если классы эквивалентности на двух последовательных итерациях совпадают, то они совпадут и на всех последующих итерациях.

\subsection{Доказательство}
\textbf{Лемма 1:} Число классов эквивалентности не возрастает на каждой итерации.

\textbf{Лемма 2:} Если классы эквивалентности совпадают на двух последовательных итерациях, то они не могут распасться на большее число классов на следующей итерации.

\textbf{Доказательство Леммы 2:}
Предположим, что есть два слова $w$ и $w'$, не эквивалентные на $i$-й итерации и эквивалентные на $(i+1)$-й итерации. Тогда существует буква $a$, такая что $\delta(q_1, a) \in F$ и $\delta(q_2, a) \notin F$.

Поскольку $w$ и $w'$ не эквивалентны на $i$-й итерации, существует слово $v$ такое, что $\delta(q_1, v) \in F$ и $\delta(q_2, v) \notin F$. Тогда слово $va$ не эквивалентно слову $w'$ на $i$-й итерации, что противоречит предположению.
\section{Доказательство факта}

\begin{itemize}
\item Предположим, что $\delta(q_1,a) \equiv \delta(q_2,a)$ по словам длины не превосходящей $l+1$.
\item Тогда существует слово $u$, длины не превосходящей $l+1$, такое что $\delta(q_1,u) \neq \delta(q_2,u)$.
\item Следовательно, $\delta(q_1,a) \not\equiv \delta(q_2,a)$ по словам длины $l$.
\end{itemize}

\section{Сужение слова}

\begin{itemize}
\item Пусть $\delta(q_1,a) \equiv \delta(q_2,a)$ по словам длины не превосходящей $l+1$.
\item Существует слово $u'$ длины не превосходящей $l$, такое что $\delta(q_1,u') \neq \delta(q_2,u')$.
\item Следовательно, $\delta(q_1,a) \not\equiv \delta(q_2,a)$ по словам длины не превосходящей $l+1$.
\end{itemize}

\section{Доказательство факта}

\begin{itemize}
\item Пусть $q_1$ и $q_2$ - эквивалентные состояния.
\item Сокращаем длину проверяемого слова на 1.
\item Если состояния эквивалентны по словам длины $l$, то они эквивалентны и по словам длины $l+1$.
\section{Алгоритм построения MPDK}
\subsection{Асимптотика алгоритма}
Асимптотика алгоритма нахождения минимального автомата равна $O(p^2q)$, где $p$ - количество состояний, а $q$ - размер алфавита.

\subsection{Шаги алгоритма}
1. Выбрать произвольную букву.
2. Разбить классы эквивалентности по этой букве.
3. Повторять шаги 1-2, пока не будут обновлены классы.

\subsection{Пример алгоритма}
\begin{itemize}
  \item Классы эквивалентности: 0, 1, 2.
  \item Переходы:
    \begin{itemize}
      \item $0 \xrightarrow{a} 1$
      \item $0 \xrightarrow{b} 2$
      \item $1 \xrightarrow{a} 2$
      \item $2 \xrightarrow{b} 0$
    \end{itemize}
  \item Результат:
    \begin{itemize}
      \item Классы эквивалентности: 0, 1+2
    \end{itemize}
\end{itemize}

\subsection{Замечание}
Алгоритм для построения MPDK был представлен в предыдущих лекциях. Он включает:
\begin{itemize}
  \item Построение регулярных выражений.
  \item Построение автомата по регулярному выражению.
  \item Дополнение автомата до полного.
  \item Минимизацию автомата.
\end{itemize}
\section{Конспект лекции}
\subsection{Построение автоматов}
- Алгоритм построения автоматов с однобуквенными переходами:
  - Удаление эпсилон-переходов
  - Построение автомата Томпсона
  - Минимизация автомата

\subsection{Классы эквивалентности}
- Количество классов эквивалентности в \textbf{автоматном языке} конечно.
- Если у языка конечно число классов эквивалентности, то язык \textbf{автоматный}.

\subsection{Теорема Махаллини-Роуд}
- Канонический \textbf{MPDK} автоматного языка имеет конечное число классов эквивалентности.
- Завершающее состояние канонического \textbf{MPDK} распознает слова из языка.
- \textbf{Теорема Махаллини-Роуд:} Если для языка существует \textbf{KMPDK} с конечным числом классов эквивалентности, то язык автоматный. Доказательство строится на построении канонического \textbf{MPDK}.
\section{Автоматные языки}
\subsection{Теорема Макиллини-Роуд}
Язык является неавтоматным, если число классов эквивалентности по этому языку бесконечно.

\subsection{Пример неавтоматного языка}
\textbf{Язык $a^vb^v$} неавтоматный, поскольку:

\begin{itemize}
  \item Существует бесконечное число классов эквивалентности: для любого $a^ib^i$ существует слово $a^ib^ic$ такое, что они не эквивалентны.
\end{itemize}

\section{Контекстно-свободные языки}
\subsection{Понятие контекстно-свободного языка}
\begin{itemize}
  \item \textbf{Контекстно-свободный язык} — язык, который можно описать \textbf{контекстно-свободной грамматикой}.
\end{itemize}

\subsection{Контекстно-свободная грамматика}
\begin{itemize}
  \item \textbf{Контекстно-свободная грамматика} — грамматика, где каждое правило имеет вид $A \to \alpha$, где $A$ — нетерминал, а $\alpha$ — строка из терминалов и/или нетерминалов.
\end{itemize}
\section{Порождающие грамматики}

\subsection{Определение}

\textbf{Грамматика} $G$ называется \textbf{порождающей}, если она состоит из:

\begin{itemize}
\item \textbf{Нетерминалов} $N$ (вспомогательных символов), $N \neq \varnothing$.
\item \textbf{Терминалов} (алфавита) $\Sigma$, $\Sigma \cap N = \varnothing$.
\item \textbf{Стартового символа} $S \in N$.
\item \textbf{Множества правил вывода} $P \subseteq N \times (N \cup \Sigma)^*$, $P \neq \varnothing$.
\end{itemize}

\subsection{Правила вывода}

Правила записываются в виде $\alpha \rightarrow \beta$, где $\alpha \in N$, $\beta \in (N \cup \Sigma)^*$.

\subsection{Пример}

Грамматика для распознавания простых предложений:

\begin{enumerate}
\item $S \rightarrow N G$
\item $N \rightarrow S$
\item $N \rightarrow A$
\item $G \rightarrow V S$
\item $V \rightarrow V$
\item $V \rightarrow S$
\item $A \rightarrow A A$
\end{enumerate}

где:

* $S$ - предложение
* $N$ - существительное
* $G$ - глагольная группа
* $V$ - глагол
* $A$ - прилагательное
\section{Конспект лекции}

\subsection{Введение}

\textbf{Грамматика} задаёт правила языка, используя:
\begin{itemize}
  \item \textbf{Объекты вида N} (с большой буквы): символы алфавита
  \item \textbf{Правила}: определяют, как объекты объединяются
\end{itemize}

\subsection{Разбор предложения}

Разобрав слова по буквам, поднимаемся на более высокий уровень:

\begin{enumerate}
  \item \textbf{Символы алфавита}: слова, токены (скобки, ключевые слова)
  \item \textbf{Правила}: распознают программы, выявляют синтаксические ошибки
\end{enumerate}

\subsection{Практическое применение}

Грамматика используется для определения правил:

\begin{itemize}
  \item Для каждой открывающей скобки должна быть закрывающая
  \item Для каждого токена есть соответствующее правило распознавания
\end{itemize}
\section{Определение выводимости в грамматиках}

\subsection{Отношение выводимости}
В грамматиках выводимость определяется как \textbf{наименьшее рефлексивное транзитивное отношение} над множеством $N \cup \Sigma^*$, где $N$ - множество нетерминалов, а $\Sigma$ - множество терминалов.

\subsection{Выводимость за один шаг}
Для любых $\alpha, \beta \in \Sigma^*$ и правила $A \rightarrow \alpha \beta$ грамматики $G$ выполняется следующее:

* $\varphi \alpha \psi \Rightarrow \varphi \beta \psi$ (выводимость за один шаг)
* $G \vdash \varphi A \psi$ (добавление символа $A$)

\section{Цель анализа грамматик}

Цель анализа грамматик - определить \textbf{язык, задаваемый грамматикой}, т. е. множество всех слов, которые могут быть выведены из стартового нетерминала.

\section{Пример}

Слово $aab$ в данной грамматике выводится следующим образом:

* $S \Rightarrow NP$
* $NP \Rightarrow N NP$
* $N \Rightarrow a$
* $NP \Rightarrow a NP$
* $N \Rightarrow b$
* $NP \Rightarrow ab$
* $S \Rightarrow ab$
* $S \Rightarrow aab$
\section{Виды грамматик}

Грамматики бывают четырех видов:

\begin{itemize}
    \item \textbf{Порождающие грамматики}
    \begin{enumerate}
        \item Правила: $\alpha \rightarrow \beta$
    \end{enumerate}

    \item \textbf{Контекстно-зависимые грамматики}
    \begin{enumerate}
        \item Правила: $\alpha \psi \rightarrow \phi \alpha$, где $\alpha \neq \emptyset$
    \end{enumerate}

    \item \textbf{Контекстно-свободные грамматики}
    \begin{enumerate}
        \item Правила: $A \rightarrow \alpha$, где $A$ — нетерминал, а $\alpha$ — последовательность терминалов и нетерминалов
    \end{enumerate}

    \item \textbf{Праволинейные (леволинейные) грамматики}
    \begin{enumerate}
        \item Правила: $A \rightarrow a \alpha$ или $\alpha A \rightarrow a$, где $A$ — нетерминал, $a$ — терминал, а $\alpha$ — последовательность терминалов и нетерминалов
    \end{enumerate}

\textbf{Важные свойства:}

\begin{itemize}
    \item Нетерминалы обозначаются большими буквами, терминалы — маленькими.
    \item Греческие буквы обозначают последовательности терминалов и нетерминалов.
    \item В контекстно-свободных грамматиках правая часть правила не может быть пустой.
\end{itemize}
\section{Иерархия языков и машин}

\textbf{Важные термины:}

* \textbf{Автоматы}
* \textbf{Контекстно-свободные языки}
* \textbf{Контекстно-зависимые языки}
* \textbf{Машина Тьюринга}
* \textbf{Линейно-ограниченная машина Тьюринга}

\subsection{Расположение автоматов в иерархии}

Автоматы находятся в столбце "Машины" иерархии языков. Это связано с тем, что грамматики, порождающие автоматные языки, не являются контекстно-свободными.

\subsection{Контекстно-свободные языки и грамматики}

Примером контекстно-свободного языка является язык слов вида $a^nb^n$. Грамматика для этого языка:

```
S → aSb | ε
```

где $S$ - начальный символ, $a$ и $b$ - терминалы, а $\varepsilon$ - пустое слово.

\subsection{Соответствие между типами грамматик и машинами}

* Порождающие грамматики - машины Тьюринга
* Контекстно-зависимые грамматики - линейно-ограниченные машины Тьюринга
* Контекстно-свободные грамматики - автоматы
\section{Свободные Контекстно-Зависимые Грамматики}

\subsection{Автоматы с Магазинной Памятью}
\begin{itemize}
\item Магазинная память = стек
\item Автомат с магазинной памятью платит со стека за переходы
\item Кладет элементы на стек
\end{itemize}

\subsection{Связь с Машинами Тьюринга}
\begin{itemize}
\item Правила грамматик задают автоматы с машинами Тьюринга
\item \textbf{Linear bounded} недетерминированные машины Тьюринга (недетерминированные машины Тьюринга с ограниченной памятью)
\end{itemize}

\section{Теорема: Эквивалентность Классов}
Множество автоматных языков эквивалентно множеству языков, задаваемых праволинейными грамматиками.

\section{Доказательство}
\subsection{Автомат по Грамматике}
\begin{itemize}
\item Состояния автомата = нетерминалы грамматики
\item Стартовое состояние = стартовый нетерминал
\item Завершающие состояния = множество завершающих нетерминалов
\item Переходы:
    \begin{itemize}
    \item Для каждого правила $A \rightarrow aB$, переход $A \xrightarrow{a} B$
    \item Для каждого правила $A \rightarrow a$, переход $A \xrightarrow{a} q_f$
    \end{itemize}
\end{itemize}
\section{Доказательство эквивалентности ДКА и Грамматик}

\subsection{Переход по двойному слову}

1. Если из состояния $a$ по символу $b$ происходит переход в состояние $b$, то вводится правило $a\rightarrow b$.
2. Если из состояния $a$ по слову $bb$ происходит переход в состояние $q_f$, то вводится правило $a\rightarrow b\varepsilon$.

\subsection{Теоремы}

1. Из состояния $a$ выводится слово $b$ в автомате $\mathcal{A}$ тогда и только тогда, когда в грамматике $\mathcal{G}$ из состояния $a$ выводится слово $bb$.
2. Из состояния $a$ выводится слово $q_f$ в автомате $\mathcal{A}$ тогда и только тогда, когда в грамматике $\mathcal{G}$ из состояния $a$ выводится слово $b$.

\subsection{Доказательство}

Доказывается индукцией по длине вывода в автомате $\mathcal{A}$.

\textbf{База:} Вывод длины $0$. Тогда $a=b$, и по определению $a\rightarrow b$ в $\mathcal{G}$.

\textbf{Шаг индукции:} Докажем оба утверждения одновременно.

1. Пусть из $a$ выводится слово $b$ в $\mathcal{A}$ за $n$ шагов. Тогда либо из $a$ в $\mathcal{A}$ происходит переход по символу $b$, либо из $a$ в $\mathcal{A}$ происходит переход по слову $bb$. В первом случае по предположению индукции из $a$ в $\mathcal{G}$ выводится слово $b$, а во втором случае по предположению индукции из $a$ в $\mathcal{G}$ выводится слово $bb$.
2. Пусть из $a$ выводится слово $q_f$ в $\mathcal{A}$ за $n$ шагов. Тогда из $a$ в $\mathcal{A}$ происходит переход по слову $bb$. Следовательно, по предположению индукции из $a$ в $\mathcal{G}$ выводится слово $bb$, и значит, из $a$ в $\mathcal{G}$ выводится слово $b$.
\section{Конспект Лекции}

\subsection{Переход 1 (из \textbf{a} в \textbf{b})}

* Из \textbf{a} выводится \textbf{c} за один шаг.
* Из \textbf{c} выводится \textbf{b} за один шаг.
* Итак, из \textbf{a} выводится \textbf{cb} за 2 шага.

\subsection{Переход 2 (из \textbf{a} в $\varepsilon$)}

* Из \textbf{a} выводится \textbf{c} за один шаг.
* Из \textbf{c} выводится $\varepsilon$ за один шаг (по предположению индукции).
* Итак, из \textbf{a} выводится \textbf{c}$\varepsilon$ за 2 шага.

\subsection{Переход в обратном направлении (из \textbf{b} в \textbf{a})}

\subsubsection{Базовый случай}

* \textbf{a} выводит \textbf{b} за 0 шагов (по определению).

\subsubsection{Индуктивный шаг}

* Пусть \textbf{a} выводит \textbf{b} за $n$ шагов.
* Тогда:
    * Из \textbf{a} выводится \textbf{c} за 1 шаг.
    * Из \textbf{c} выводится \textbf{b} за $n-1$ шаг (по предположению индукции).
* Итак, из \textbf{a} выводится \textbf{cb} за $n+1$ шаг.

\subsection{Переход в обратном направлении (из $\varepsilon$ в \textbf{a})}

\subsubsection{Базовый случай}

* \textbf{a} выводит $\varepsilon$ за 0 шагов (по определению).

\subsubsection{Индуктивный шаг}

* Пусть \textbf{a} выводит $\varepsilon$ за $n$ шагов.
* Тогда:
    * Из \textbf{a} выводится \textbf{c} за 1 шаг.
    * Из \textbf{c} выводится $\varepsilon$ за $n-1$ шаг (по предположению индукции).
* Итак, из \textbf{a} выводится \textbf{c}$\varepsilon$ за $n+1$ шаг.
\section{Доказательство эквивалентности грамматики и автомата}

\subsection{Доказательство в одну сторону}

Для доказательства того, что язык, задаваемый грамматикой, совпадает с языком, задаваемым автоматом, необходимо показать, что:

\begin{itemize}
    \item Каждое слово, выводимое в грамматике, принимается автоматом.
    \item Каждое слово, принимаемое автоматом, выводится в грамматике.
\end{itemize}

\subsubsection{Первая часть доказательства}

Докажем первую часть по индукции по длине слова:

* \textbf{База}: Для пустого слова $w=\varepsilon$ переход из $q_0$ по $\varepsilon$ приводит в состояние $q_f$, которое является принимающим. Следовательно, $\varepsilon\in L(G)$.
* \textbf{Индукционный шаг}: Предположим, что для всех слов длины $n$ утверждение верно. Рассмотрим слово $w=x\alpha$, где $x$ - нетерминальный символ, а $\alpha$ - слово длины $n$. По предположению индукции, существует состояние $q$ такое, что $q_0\xrightarrow{x}q$. Из $q$ по $\alpha$ существует переход в состояние $q_f$. Следовательно, $w\in L(G)$.

\subsubsection{Вторая часть доказательства}

Докажем вторую часть по индукции по числу шагов в автомате:

* \textbf{База}: Если слово $w$ принимается автоматом за один шаг (т.е. $q_0\xrightarrow{w}q_f$), то $w$ выводится в грамматике по правилу $x\rightarrow w$.
* \textbf{Индукционный шаг}: Предположим, что для всех слов, принимаемых автоматом за $n$ шагов, утверждение верно. Рассмотрим слово $w$ длины $n+1$, принимаемое автоматом за $n+1$ шаг. По последнему шагу перехода автомата существует состояние $q$ такое, что $q_0\xrightarrow{x}q$ и $q\xrightarrow{\alpha}q_f$, где $w=x\alpha$. По предположению индукции, слово $\alpha$ выводится в грамматике по правилу $x\rightarrow\alpha$. Следовательно, $w$ выводится в грамматике по правилу $x\rightarrow x\alpha$.

\subsection{Доказательство в обратную сторону}

Докажем, что язык, задаваемый автоматом, совпадает с языком, задаваемым грамматикой, используя контрапозицию:

* Предположим, что слово $w\notin L(G)$. Тогда не существует никакой цепочки вывода $w$ в грамматике.
* По индукции можно доказать, что для любого слова $w$, которое не выводится в грамматике, не существует состояния $q$ такого, что $q_0\xrightarrow{w}q$ (для любого состояния $q$).
* Следовательно, $w\notin L(A)$, где $A$ - автомат, построенный по грамматике $G$.
\section{От Автомата к Грамматике}

\subsection{Построение Грамматики}

Из автомата $M = (\Sigma, \Delta, Q, \delta, Q_0, F)$ можно построить грамматику $G = (N, \Sigma, P, S)$, где:

* $N = Q$ - множество нетерминалов;
* $\Sigma$ - множество терминалов;
* $P$ - набор правил вывода:
    * Для перехода $\delta(q_1, a) = q_2$ добавляется правило $q_1 \rightarrow q_2a$;
    * Для завершающих состояний $q_f \in F$ добавляется правило $q_f \rightarrow \epsilon$.

\subsection{Замечание}

Если $\Sigma$ и $Q$ пересекаются, то дублируются все состояния, которые являются элементами $\Sigma$.
\section{Преобразование Автоматов с Недетерминированными Переходами}

\subsection{Устранение Знака Существования}

Для устранения знака существования в автомате необходимо доказать, что в нем существует ровно одно завершающее состояние. Это можно сделать с помощью индукции по длине выводов грамматики.

\subsection{Индукция слева направо}

\textbf{База:} Для вывода длины $0$ имеем $q_1 \xrightarrow{\varepsilon} q_2$, где $\varepsilon$ - пустая строка.

\textbf{Переход:} Предположим, что для всех выводов длины $n$ существует ровно одно завершающее состояние. Докажем это для выводов длины $n+1$.

Рассмотрим переход $q \xrightarrow{x} q'$ и дальнейший переход $q' \xrightarrow{\varepsilon} q_2$.

* Из предположения индукции следует, что для вывода $q_1 \xrightarrow{x} q$ существует ровно одно завершающее состояние $q$.
* Следовательно, для вывода $q_1 \xrightarrow{x} q \xrightarrow{\varepsilon} q_2$ существует ровно одно завершающее состояние $q_2$.

Значит, для всех выводов длины $n+1$ существует ровно одно завершающее состояние.
\section{Конспект Лекции}

\subsection{Вывод}

- Вывод из состояния \textbf{q1} в состояние \textbf{q2} происходит по \textit{символу x}.

- Вывод из состояния \textbf{q1} в состояние \textbf{q2} происходит по любому символу.

- Вывод из состояния \textbf{q1} в состояния \textbf{q2} и \textbf{q3} происходит по \textit{символу x}.

\subsection{Завершающее Состояние}

- Для определения завершающего состояния необходимо добавить квантор существования:

- Состояние \textbf{q1} является завершающим, если существует путь из \textbf{q1} в \textbf{q2}.
\end{document}